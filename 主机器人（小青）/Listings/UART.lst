C51 COMPILER V9.59.0.0   UART                                                              07/16/2024 15:05:46 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\UART.obj
COMPILER INVOKED BY: G:\Keil_v5\C51\BIN\C51.EXE UART.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\UART.lst) TA
                    -BS(2) OBJECT(.\Objects\UART.obj)

line level    source

   1          # include "uart.h"
   2          #define  uint8   unsigned char
   3          #define  uint16  unsigned int 
   4          extern  unsigned char cmd;
   5          #define BAUD  115200                       // 波特率
   6          #define BAUD3 19200 
   7          #define BAUD4 115200
   8          #define S2_S  0x01  
   9          #define S2RI 0x01
  10          #define S2TI 0x02
  11          #define S3RI 0x01
  12          #define S3TI 0x02
  13          #define S4RI 0x01
  14          #define S4TI 0x02
  15          #define Buf_MaxOPEN 1                     //定义数组大小
  16          #define Buf_MaxASR  3
  17          #define Buf_MaxDUO 14
  18          #define Buf_MaxTS   4
  19          uint8 xdata Rec_Buf1[Buf_MaxTS];         //调试舵机接收数据
  20          uint8 xdata Rec_Buf2[Buf_MaxASR];        //语音识别模块接收缓存
  21          uint8 xdata Rec_Buf3[Buf_MaxDUO];        //接收串口3缓存数组
  22          uint8 xdata Rec_Buf4[Buf_MaxOPEN];           //接收串口4缓存数组
  23          uint8 i = 0;      
  24          uint8 j = 0; 
  25          uint8 m = 0;      
  26          uint8 n = 0;
  27          //==================================================================================
  28          //设置IO口--------------------------------------------------------------------------
  29          void wagh()
  30          {
  31   1        P0M1 = 0; P0M0 = 0; //设置P0.0~P0.7为准双向口
  32   1        P1M1 = 0; P1M0 = 0; //设置P1.0~P1.7为准双向口
  33   1        P2M1 = 0; P2M0 = 0; //设置P2.0~P2.7为准双向口 
  34   1        P3M1 = 0; P3M0 = 0; //设置P3.0~P3.7为准双向口
  35   1        P4M1 = 0; P4M0 = 0; //设置P4.0~P4.7为准双向口
  36   1        P5M1 = 0; P5M0 = 0; //设置P5.0~P5.7为准双向口
  37   1      }
  38          //延时函数---------------------------------------------------------------------------
  39          void delay_ms(unsigned  int x) 
  40          {  
  41   1        unsigned int j,i;   
  42   1        for(j=0;j<x;j++)   
  43   1        {    
  44   2          for(i=0;i<1100;i++);   
  45   2        }  
  46   1      }
  47          //串口1初始化函数--------------------------------------------------------------------
  48          void Uart1234_Init(void)
  49          { 
  50   1        P_SW1|=0X00;        //选择P16 P17为串口1
  51   1        P_SW1&=0XFF;        //选择P16 P17为串口1
  52   1        P_SW2|=S2_S;        //选择P46 P47为串口2
  53   1        //串口1配置 
  54   1        PCON &= 0x3f;       //（0011 1111）串口1波特率不倍速
C51 COMPILER V9.59.0.0   UART                                                              07/16/2024 15:05:46 PAGE 2   

  55   1        SCON = 0x50;        //（0101 0000）串口1的8位数据,可变波特率，启动串行接收器（工作方式一）
  56   1        AUXR |= 0x01;       //（0000 0000）串口1选择定时器2为波特率发生器
  57   1        //串口2配置 
  58   1        S2CON = 0x50;       //串口2的8位数据,可变波特率 
  59   1        //串口3配置 
  60   1        S3CON |= 0x50;      //串口3启动串行接收器
  61   1        S3CON &= 0x70;      //串口3选择定时器2为波特率发生器，8位数据,可变波特率
  62   1        //串口4配置 
  63   1        S4CON |= 0x10;      //（0001 0000）启动串行接收器 
  64   1        S4CON &= 0x30;      //（0011 0000）8位数据,可变波特率，串口4选择定时器2为波特率发生器
  65   1        S4CON |= 0x40;    //串口4选择定时器4为波特率发生器
  66   1        
  67   1        AUXR |= 0x04;       //定时器2时钟为Fosc,即1T  
  68   1        T2L=(65536-(MAIN_Fosc/4/BAUD));
  69   1        T2H=(65536-(MAIN_Fosc/4/BAUD))>>8;        //设定定时初值
  70   1        AUXR |= 0x10;       //启动定时器2
  71   1        
  72   1        T4T3M |= 0x22;    //定时器3时钟为Fosc,即1T/定时器4时钟为Fosc,即1T
  73   1        T3L=(65536-(MAIN_Fosc/4/BAUD3));
  74   1        T3H=(65536-(MAIN_Fosc/4/BAUD3))>>8;
  75   1        T4L=(65536-(MAIN_Fosc/4/BAUD4));
  76   1        T4H=(65536-(MAIN_Fosc/4/BAUD4))>>8;
  77   1        T4T3M |= 0x88;    //启动定时器3和4
  78   1        
  79   1      }
  80          //========================================================================================================
             -===
  81          //串口1发送字符函数
  82          void SendDataByUart1(uint8 dat)
  83          {
  84   1          SBUF = dat;                 //写数据到UART数据寄存器
  85   1          while(TI == 0);             //在停止位没有发送时，TI为0即一直等待
  86   1          TI = 0;                     //清除TI位（该位必须软件清零）
  87   1      }
  88          
  89          //串口1发送字符串函数
  90          
  91          void SendStringByUart1(uint8 *s)
  92          {
  93   1        while(*s)
  94   1        {
  95   2          SendDataByUart1(*s++);       //将字符串中的字符一个一个发送
  96   2        }
  97   1      }
  98          void Uart1() interrupt UART1_VECTOR using 1
  99          {
 100   1        ES = 0;                       // 串口1中断关闭
 101   1        if (RI)                       //串行接收到停止位的中间时刻时，该位置1
 102   1        {
 103   2            RI = 0;                   //清除RI位 （该位必须软件清零）
 104   2            Rec_Buf1[i] = SBUF;       //把串口1缓存SBUF寄存器数据依次存放到数组Rec_Buf1中
 105   2            i++;                      
 106   2            if(i>=Buf_MaxTS)             //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
 107   2              {
 108   3                i = 0;                 
 109   3              }           
 110   2         }
 111   1         if (TI)                    //在停止位开始发送时，该位置1
 112   1         {
 113   2            TI = 0;                 //清除TI位（该位必须软件清零）
 114   2         }
 115   1         ES =  1;                   // 串口1中断打开
C51 COMPILER V9.59.0.0   UART                                                              07/16/2024 15:05:46 PAGE 3   

 116   1      }
 117          ////======================================================================================================
             -=====
 118          ////串口2发送字符函数
 119          void SendDataByUart2(uint8 dat)
 120          {
 121   1          S2BUF = dat;                 //写数据到UART数据寄存器
 122   1          while(!(S2CON&S2TI));        //在停止位没有发送时，S2TI为0即一直等待
 123   1          S2CON&=~S2TI;                //清除S2CON寄存器对应S2TI位（该位必须软件清零）
 124   1      }
 125          void CLR_Buf2(void)
 126          {
 127   1        unsigned char k;
 128   1        for(k=0;k<Buf_MaxASR;k++)      //将串口2缓存数组的值都清为零
 129   1        {
 130   2           Rec_Buf2[k] = 0;
 131   2        }
 132   1        j = 0;                    
 133   1      }
 134          void Uart2() interrupt UART2_VECTOR using 1
 135          {
 136   1        IE2 &= 0xFE;                                // 串口2中断关闭
 137   1        if (S2CON & S2RI)                           //串行接收到停止位的中间时刻时，该位置1
 138   1        {
 139   2            S2CON &= ~S2RI;                         //清除S2CON寄存器对应S2RI位（该位必须软件清零）
 140   2            Rec_Buf2[j] = S2BUF;                    //把串口2缓存SBUF寄存器数据依次存放到数组Rec_Buf2中            
             -                      
 141   2            j++;
 142   2          
 143   2            if(j>Buf_MaxASR)                          //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
 144   2              {
 145   3                  j = 0;
 146   3              }     
 147   2         }
 148   1            if (S2CON & S2TI)                       //在停止位开始发送时，该位置1
 149   1            {
 150   2              S2CON &= ~S2TI;                       //清除S2CON寄存器对应S2TI位（该位必须软件清零）
 151   2            }  
 152   1         IE2 |= 0x01;                               // 串口2中断打开  
 153   1      }
 154          //////====================================================================================================
 155          //串口3发送数据函数
 156          void SendDataByUart3(uint8 dat)
 157          {
 158   1          S3BUF = dat;                 //写数据到UART数据寄存器
 159   1          while(!(S3CON&S3TI));        //在停止位没有发送时，S3TI为0即一直等待
 160   1          S3CON&=~S3TI;                //清除S3CON寄存器对应S3TI位（该位必须软件清零）
 161   1      }
 162          
 163          // 串口3发送字符串函数
 164          void SendStringByUart3(uint8 *s)
 165          {
 166   1          IE2 &= 0xF7;                     // 串口3中断关闭
 167   1          while (*s)                       //检测字符串结束标志
 168   1          {
 169   2            SendDataByUart3(*s++);         //发送当前字符
 170   2          }
 171   1          IE2 |= 0x08;                     // 串口3中断打开
 172   1      }
 173          //清除缓存内容函数
 174          void CLR_Buf3(void)
 175          {
C51 COMPILER V9.59.0.0   UART                                                              07/16/2024 15:05:46 PAGE 4   

 176   1          uint8 k;
 177   1          for(k=0;k<Buf_MaxDUO;k++)      //将串口3缓存数组的值都清为零
 178   1          {
 179   2               Rec_Buf3[k] = 0;
 180   2          }
 181   1          m = 0;                    
 182   1      }
 183          
 184          void Uart3() interrupt UART3_VECTOR using 1
 185          {
 186   1        IE2 &= 0xF7;                     // 串口3中断关闭
 187   1        if (S3CON & S3RI)                //串行接收到停止位的中间时刻时，该位置1
 188   1        {
 189   2            S3CON &= ~S3RI;              //清除S3CON寄存器对应S3RI位（该位必须软件清零）
 190   2            Rec_Buf3[m] = S3BUF;         //把串口3缓存SBUF寄存器数据依次存放到数组Rec_Buf3中
 191   2            m++;               
 192   2            if(m>Buf_MaxDUO)                //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
 193   2              {
 194   3                m = 0;
 195   3              }     
 196   2         }
 197   1        if (S3CON & S3TI)                //在停止位开始发送时，该位置1
 198   1         {
 199   2            S3CON &= ~S3TI;              //清除S3CON寄存器对应S3TI位（该位必须软件清零）
 200   2         }
 201   1         IE2 |= 0x08;                     // 串口3中断打开
 202   1      }
 203          //////====================================================================================================
             -====
 204          void SendDataByUart4(uint8 dat)
 205          {
 206   1          S4BUF = dat;                 //写数据到UART数据寄存器
 207   1          while(!(S4CON&S4TI));        //在停止位没有发送时，S4TI为0即一直等待
 208   1          S4CON&=~S4TI;                //清除S4CON寄存器对应S4TI位（该位必须软件清零）
 209   1      }
 210          //串口4发送字符串函数
 211          void SendStringByUart4(char *s)
 212          {
 213   1        IE2 &= 0xEF;                     //串口4中断关闭
 214   1        while (*s)                       //检测字符串结束标志
 215   1        {
 216   2          SendDataByUart4(*s++);         //发送当前字符
 217   2        }
 218   1        IE2 |= 0x10;                     //串口4中断打开
 219   1      }
 220          //清除缓存内容函数
 221          void CLR_Buf4(void)
 222          {
 223   1        unsigned char k;
 224   1        for(k=0;k<Buf_MaxOPEN;k++)         //将串口4缓存数组的值都清为零
 225   1        {
 226   2           Rec_Buf4[k] = 0;
 227   2        }
 228   1        n = 0;                    
 229   1      }
 230          
 231          //串口4中断服务函数
 232          void Uart4() interrupt UART4_VECTOR
 233          {     
 234   1        IE2 &= 0xEF;                // 串口4中断关闭  
 235   1        if(S4CON & S4RI)           //串行接收到停止位的中间时刻时，该位置1
 236   1        {
C51 COMPILER V9.59.0.0   UART                                                              07/16/2024 15:05:46 PAGE 5   

 237   2          S4CON &= ~S4RI;          //清除S4CON寄存器对应S4RI位（该位必须软件清零）
 238   2          Rec_Buf4[n] = S4BUF;     //把串口4缓存SBUF寄存器数据依次存放到数组Rec_Buf4中
 239   2          n++;               
 240   2          if(n>=Buf_MaxOPEN)            //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
 241   2          {
 242   3              n = 0;
 243   3          }
 244   2        }
 245   1        if(S4CON & S4TI)           //在停止位开始发送时，该位置1
 246   1         {
 247   2          S4CON &= ~S4TI;          //清除S4CON寄存器对应S4TI位（该位必须软件清零）
 248   2         }
 249   1         IE2 |= 0x10;              // 串口4中断打开
 250   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    656    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     22    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
